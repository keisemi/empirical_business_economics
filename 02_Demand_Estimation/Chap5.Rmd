---
title: "「実証ビジネス・エコノミクス」第５章 <br> 「合併の効果は需要次第：消費者需要モデルの推定【応用編】」"
author: "上武康亮・遠山祐太・若森直樹・渡辺安虎"
date: '最終更新: `r Sys.Date()`'
output:
  html_document: 
    code_folding: show
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# はじめに

「実証ビジネス・エコノミクス」の第5章「合併の効果は需要次第：消費者需要モデルの推定【応用編】」に関するRプログラムの紹介である。

## 留意事項

本連載の内容、およびサンプルコード等の資料は、情報の提供のみを目的としていますので、運用につきましては十分にご確認をいただき、お客様ご自身の責任とご判断によって行ってください。これらの情報の運用結果により損害等が生じた場合でも、日本評論社および著者はいかなる責任を負うことはできませんので、ご留意ください。

## 謝辞

今回のプログラムの作成に際して、島本幸典さん・牧野圭吾さん・山田雅広さん(東京大学大学院経済学研究科)にご尽力頂きました。


# Rに関する下準備

今回は`tictoc`を新たに利用する。
なお、以下の`require`で読み込んでいるパッケージについてまだインストールしていない場合には、最初にインストールすること。

```{r message=FALSE}
# ワークスペースを初期化
rm(list = ls())

# (もしまだなら) パッケージのインストール
# install.packages("tidyverse")
# install.packages("kableExtra")
# install.packages("sjmisc")
# install.packages("knitr")
# install.packages("tictoc")

# パッケージを読み込む
require(tidyverse)
require(kableExtra)
require(sjmisc)
require(knitr)
require(tictoc)
```

また、`tictoc`パッケージを用いて時間計測を行う。`tictoc::tic()`で時間計測を開始し、`tictoc::toc()`で計測を終了し、そこまでの時間がレポートされる。推定に比較的時間がかかるような場合においては、コードの時間計測を適宜行うと作業の見通しが立ちやすくなる。

```{r}
tictoc::tic()
```

# データの準備

第４章の「6 入れ子型ロジットモデルの推定とその応用」までで作成したデータを読み込む

```{r message = FALSE}
data <- readr::read_csv(file = "intermediate/chap4_data.csv")
```

# ランダム係数ロジットモデルの推定

第４章に従って、ランダム係数ロジットモデルを推定する。
なお、コード自体は前回とほぼ同様であるため、詳細な説明は省く。詳しくは第４章のコードを参照されたい。

## 定式化

以下の定式化を考える。

$$
\begin{eqnarray}
u_{i j t}=& \beta^{0}+\beta^{size}{size}_{j t}+\beta^{\textit{fuelefficiency}}\textit{fuelefficiency}_{jt} 
+\beta^{h p p w} h p p w_{j t}+\beta^{capacity\_d}{capacity\_d_{j t}}\\
&+\beta^{FuelRegular\_d}{FuelRegular\_d_{jt}}+\beta^{Foreign\_d}{Foreign\_d_{jt}}
-\alpha_{i} p_{j t}+\xi_{j t}+\lambda_t+\epsilon_{i j t}
\end{eqnarray}
$$

ここで、$\alpha_i$は正規分布に従うランダム係数である。


## データの下準備

まずは、データセットから、行列を抽出する。

```{r}
# まずデータをソートする。マーケット順、メーカー順かつ価格順
data %>% 
  arrange(year, Maker, price) -> data

# データセットより抽出した行列等をdatalistに格納する
datalist <- list()

# 平均効用に入ってくる部分。内生性がある価格を含んでいる。
datalist$X1 <-
  data %>%
  mutate(cons = 1) %>%
  # 価格を必ず2つ目にする
  select(cons, price, FuelEfficiency, hppw, size, 
         capacity_d, FuelRegular_d, Foreign_d,
         starts_with("year_")
  ) %>% 
  as.matrix()

# ランダム係数とInteractする部分。
datalist$X2 <-
  data %>%
  mutate(cons = 1) %>%
  # 価格を必ず1つ目にする
  select(price) %>% 
  as.matrix()

# 操作変数行列。ここは外生変数と追加的な操作変数を含む
datalist$Z <-
  data %>%
  mutate(cons = 1) %>%
  select(
    cons, FuelEfficiency, hppw, size,
    capacity_d, FuelRegular_d, Foreign_d,
    starts_with("year_"),
    starts_with("iv_GH"),
    -ends_with("nest")
    ) %>% 
  as.matrix()

# 市場シェア
datalist$ShareVec <-
  data %>%
  select(share) %>%
  as.matrix()

datalist$marketindex <- data$year
datalist$logitshare <- data$logit_share

# 観察数、年数を取得
N <- length(datalist$marketindex)
T <- length(unique(datalist$marketindex))
```


次に、乱数を用意しておく。

```{r}
set.seed(111)
Nsim <- 1000
datalist$draw_vec <- rnorm(Nsim * ncol(datalist$X2))

parameter <- list()
parameter$Nsim <- Nsim
parameter$T <- T 
parameter$N <- N
marketindex <- datalist$marketindex
uniquemarketindex <- sort(unique(marketindex))
temp1 <- matrix(rep(uniquemarketindex, N), T, N) %>% t()
temp2 <- matrix(rep(marketindex, T), N, T)
mkt_denom_d <- (temp1 == temp2) * 1
datalist$mkt_denom_d <- mkt_denom_d
```


## 各種関数の定義

前回と同様にGMM推定に必要な関数を定義していく。これらは前回と同じである。

1. 市場シェアを計算する関数 `f_marketshare`
2. 縮小写像によるBerryインバージョンを行う関数 `f_contraction` 
3. GMMの目的関数 `f_GMMobj`
4. 標準誤差の計算 `f_SE`
5. 価格弾力性の計算 `f_elasticity`

### 市場シェアの計算コード

ここでは、市場シェアを計算する関数`f_mktshare`を定義しよう。

```{r}
f_mktshare <- function(datalist, parameter, delta, theta2) {
  
  # datalist, parameterの中身を読み込む
  X2 <- datalist$X2
  N <- length(datalist$marketindex)
  T <- length(unique(datalist$marketindex))
  draw_vec <- datalist$draw_vec
  marketindex <- datalist$marketindex
  mkt_denom_d <- datalist$mkt_denom_d
  Nsim <- parameter$Nsim
  K2 <- length(theta2)
  
  # Nonlinear component. mu (N, ns) matrix.
  mu <- X2 %*% diag(x = theta2, nrow = K2) %*% matrix(draw_vec, nrow = K2)
  delta_mu <- delta %*% matrix(1, nrow = 1, ncol = Nsim) + mu
  exp_delta_mu <- exp(delta_mu)
  
  # ロジット確率の分母を計算する。これは、市場ごとに和を計算する。
  denom_temp <- t(t(exp_delta_mu) %*% mkt_denom_d)
  denom_outside <- exp(matrix(0, T, Nsim))
  denom_temp <- denom_temp + denom_outside
  
  # denom is (N * ns) matrix that captures the denominator of the logit prob.
  denom <- mkt_denom_d %*% denom_temp
  
  # Choice prob for individual (N * ns) matrix
  s_jt_i <- exp_delta_mu / denom
  
  # Market share (N * 1) vector
  s_jt <- apply(s_jt_i, 1, mean)
  
  return(s_jt)
}
```

### 縮小写像によるBerryインバージョンのコード

ここでは、Berryインバージョンによる平均効用の計算を行う関数を定義する。なお、関数の内部でStep2で定義した`f_mktshare`を利用している。

```{r}
f_contraction <- function(datalist, parameter, delta_ini, theta2) {
  
  # 初期値の代入
  ShareVec <- datalist$ShareVec
  exp_delta_old <- exp(delta_ini)
  
  # 収束の設定
  tol <- 1e-11
  norm <- 1e+10
  iter <- 0
  while (norm > tol && iter < 1000){
    # マーケットシェアの計算
    pred_mkt_share <- f_mktshare(datalist, parameter, log(exp_delta_old), theta2)
    # deltaを更新
    exp_delta <- exp_delta_old * ShareVec / pred_mkt_share
    # 距離を評価
    norm <- max(abs(exp_delta - exp_delta_old))
    # 計算結果を次のループに渡す
    exp_delta_old <- exp_delta 
    iter <- iter + 1
  }
  return(log(exp_delta))
}
```

### GMM 目的関数を定義

```{r}
f_GMMobj <- function(theta2, parameter, datalist, option) {
  # 引数option
  # 0:最適化の際に指定
  # 1:推定値やmean utility(delta)を得る際に指定

  # Contractionの初期値として、グローバル変数のdelta_globalを用いる。
  delta_ini <- delta_global
  
  # Contraction mapping
  delta <- f_contraction(datalist, parameter, delta_ini, theta2)
  
  # 平均効用を永続代入演算子でアップデートしている。 
  delta_global <<- delta
  
  # 目的関数に必要な行列を準備
  X1 <- datalist$X1
  Z <- datalist$Z
  
  # Weight matrix W
  if (datalist$weight_mat_option == "2SLS") {
    W <- solve(t(Z) %*% Z)
  } else if (datalist$weight_mat_option == "Ident") {
    W <- eye(dim(Z)[2])
  } else if (is.null(datalist$weight_mat_option)) {
    stop("SET 'datalist$weight_mat_option' !!")
  }
  
  # Obtain linear parameter by regression
  theta1 <- solve(t(X1) %*% Z %*% W %*% t(Z) %*% X1) %*% t(X1) %*% Z %*% W %*% t(Z) %*% delta
  # xiを計算
  Xi <- delta - X1 %*% theta1
  
  # Objective function
  output <- t(Xi) %*% Z %*% W %*% t(Z) %*% Xi
  
  # optionによって戻り値を変える
  if (option == 0) {
    return(output = output)
  } else if (option == 1) {
    return(list(output = output, theta1 = theta1, delta = delta, Xi = Xi))
  } else {
    stop(
      "SET the argument 'option' to 0 or 1 !! \n 
      0: Specify when optimizing \n
      1: Specify when getting coefficient and mean utility (delta)"
    )
  }
}
```

### 標準誤差の計算


```{r}
f_SE <- function(theta2, parameter, datalist) {
  param <- parameter
  
  delta_ini <- datalist$logitshare
  
  # Contraction mapping
  delta <- f_contraction(datalist, param, delta_ini, theta2)
  
  # Obj function
  X1 <- datalist$X1
  
  # IV matrix
  Z <- datalist$Z
  
  # Weight matrix W
  if (datalist$weight_mat_option == "2SLS") {
    W <- solve(t(Z) %*% Z)
  } else if (datalist$weight_mat_option == "Ident") {
    W <- eye(dim(Z)[2])
  } else if (is.null(datalist$weight_mat_option)) {
    STOP("SET 'datalist$weight_mat_option' !!")
  }
  
  # Obtain linear parameter by regression
  theta1 <- solve(t(X1) %*% Z %*% W %*% t(Z) %*% X1) %*% t(X1) %*% Z %*% W %*% t(Z) %*% delta
  
  # ResidualをGetする。
  Xi <- delta - X1 %*% theta1
  
  # Omega
  Omega_hat <- matrix(0, nrow = ncol(Z), ncol = ncol(Z))
  for (ii in 1:param$N) {
    Omega_hat <- Omega_hat + (matrix(Z[ii, ]) %*% t(matrix(Z[ii, ])) * Xi[ii]^2) / parameter$N
  }
  
  # Gradient of delta. 単純化のために数値微分で計算する。
  Ddelta <- matrix(0, nrow = parameter$N, ncol = length(theta2))
  
  for (k in 1:length(theta2)) {
    tempparam <- param
    temptheta2 <- theta2
    temptheta2[k] <- theta2[k] + 1e-6
    
    delta_add <- f_contraction(datalist, tempparam, delta_ini, temptheta2)
    
    Ddelta[, k] <- (delta_add - delta) / 1e-6
  }
  
  G <- (parameter$N^(-1)) * t(Z) %*% cbind(-X1, Ddelta)
  #G <-  t(Z) %*% cbind(-X1, Ddelta)
  
  # Asymptotic Var-Cov Matrix
  AsyVarMat <- solve(t(G) %*% W %*% G) %*% t(G) %*% W %*% Omega_hat %*% W %*% G %*% solve(t(G) %*% W %*% G)
  # Asymptotic Standard Errors.
  Ase <- sqrt(diag(AsyVarMat) / parameter$N)
  
  return(Ase)
}
```


### 価格弾力性を計算する関数

このコードも基本的に前回と同様である。

```{r}
f_elasticity <- function(datalist, parameter, theta1, theta2, delta) {
  # Unpack data
  X2 <- datalist$X2
  Nsim <- parameter$Nsim
  N <- parameter$N
  price <- datalist$X1[, colnames(datalist$X1) == "price"] %>% as.matrix()
  K2 <- length(theta2)
  draw_vec <- datalist$draw_vec
  uniquemarketindex <- datalist$uniquemarketindex
  
  # 以下マーケットシェアの関数とほぼ同じ
  # Nonlinear component. mu (N, ns) matrix.
  mu <- X2 %*% diag(x = theta2, nrow = K2) %*% matrix(draw_vec, nrow = K2)
  
  denom_outside <- exp(matrix(0, T, Nsim))
  delta_mu <- delta %*% matrix(1, nrow = 1, ncol = Nsim) + mu
  exp_delta_mu <- exp(delta_mu)
  mkt_denom_d <- datalist$mkt_denom_d
  denom_temp <- t(t(exp_delta_mu) %*% mkt_denom_d)
  denom_temp <- denom_temp + denom_outside
  denom <- mkt_denom_d %*% denom_temp
  
  # Choice prob for individual (N * ns) matrix
  s_jt_i <- exp_delta_mu / denom
  
  # Price parameter alpha_i
  draw_for_price <- matrix(draw_vec, nrow = K2)[1, ]
  
  # theta1のなかで2つ目、theta2のなかで1つ目に価格係数がある
  alpha_i <- theta1[2] + theta2[1] * draw_for_price
  
  # 弾力性行列を保存する空のリストを作成する
  elaslist <- as.list(rep(NA, T))
  
  # 各マーケットごとに弾力性行列を作成する．
  for (t in 1:T) {
    year_beg <- 2016 - T 
    # Number of products 
    J_t <- sum(marketindex == year_beg + t)
    
    # それぞれのマーケットに注目した(J*ns)の選択確率の行列を作成する
    # あるマーケットに対して，製品ごとに集計した選択確率の行列(J*ns)を作成する
    ag_model_s_i <- s_jt_i[marketindex == year_beg + t,]
    
    # 製品ごとの選択確率のベクトル(J * 1)
    ag_model_s <- apply(ag_model_s_i, 1, mean) %>% as.matrix()
    
    # 空の弾力性行列(J * J)を定義
    elasmat <- matrix(0, nrow = J_t, ncol = J_t)
    
    # あるマーケットに注目した，製品ごとの価格のベクトル(J*1)を作成する
    price_t <- price[marketindex == year_beg + t]
    
    # 弾力性を計算し，弾力性行列を作成する
    for (k in 1:J_t) {
      for (j in 1:J_t) {
        if (k != j) {
          # cross elasticity
          elasmat[k, j] <- (-1)*price_t[k] * ag_model_s[j, ]^(-1) * mean(alpha_i * ag_model_s_i[j, ] * ag_model_s_i[k, ])
        } else if (k == j) {
          # Own elasticity
          elasmat[k, j] <- price_t[j] * ag_model_s[j, ]^(-1) * mean(alpha_i * ag_model_s_i[j, ] * (1 - ag_model_s_i[j, ]) )
        } 
      }
    }
    # 弾力性行列をマーケットごとに名前を付けて保存する．
    elaslist[[t]] <- elasmat
    names(elaslist)[[t]] <- sprintf("elasmat_%d", t + year_beg)
  }
  return(elaslist)
}
```


## パラメタ推定及び標準誤差の計算

上で定義した関数を用いてGMM推定を行う。

```{r}
# GMMの荷重行列のオプション
datalist$weight_mat_option <- "2SLS"

# グローバル変数としてアップデートする平均効用
delta_global <- data$logit_share
# 最適化
GMM_nonlinear <- 
  optim(par = c(0.7), 
        fn = f_GMMobj,
        method = "L-BFGS-B",
        lower = c(0), 
        parameter = parameter,
        datalist = datalist,
        option = 0)

# nonlinear parameter estimates
theta2_hat <- GMM_nonlinear$par
```

推定値に基づいて標準誤差の計算を行う。

```{r}
GMM_linear <- f_GMMobj(theta2_hat, parameter, datalist, option = 1)

# deltaと観測されないXiをdataに保存
delta <- GMM_linear$delta
Xi <- GMM_linear$Xi

data <- data %>%
  mutate(Xi = Xi, delta = delta)

# linear parameter estimates
theta1_hatmat <- GMM_linear$theta1
theta1_hat <- as.vector(theta1_hatmat)

se <- f_SE(theta2 = theta2_hat, parameter = parameter, datalist = datalist)
```

以上に基づいて、推定値のテーブルを出力する。

```{r}
theta2_hatmat <- as.matrix(theta2_hat)
rownames(theta2_hatmat)[1] <- "random_price"
beta_hat <- rbind(theta1_hatmat, theta2_hatmat) 
colnames(beta_hat) <- "coeff"
names(se)[length(GMM_linear$theta1) + 1] <- "random_price"

est_table <- as.data.frame(cbind(beta_hat, se))
est_table %>%
  kable(align = c("l", rep("c", 2)),
        digits = 2, 
        booktabs = FALSE, format = "html",
        caption = "Estimates of The Parameters") %>%
  kable_styling(full_width = FALSE)

# 表の保存
est_table %>%
  kable(align = c("l", rep("c", 2)),
        digits = 2, 
        booktabs = FALSE, format = "latex",
        caption = "Estimates of The Parameters") %>%
  kable_styling(full_width = FALSE) %>%
  save_kable("output/chap5_blp.tex")
```


# 限界費用の推定

需要推定の結果に基づいて、限界費用を推定する。

差別化財ベルトラン競争モデルのナッシュ均衡条件に基づき、限界費用は以下の式で求める。
$$\hat{mc} = p^* - \Delta^{pre}(p^*)^{-1}q(p^*)$$
ちなみに

$$\Delta^{pre}_{jr}(p) = \left\{
\begin{array}{ll}
- \frac{\partial q_j(p)}{\partial p_r} & {\rm if} \ (r,j) \in \mathcal{F}_f \\
0 & その他
\end{array}
\right.$$

これは需要推定値から求めることができる。詳しくは本誌を参照されたい。

以上の考え方に基づいて、限界費用を推定する関数を作成する。


```{r}
f_Merginal_Cost_Est <- function(data, marketindex, elasticity) {
  # マーケットの数を取り出す
  T <- length(unique(data$year))
  
  # 限界費用を保存する空のリストを作成する
  MC_list <- as.list(rep(NA, T))
  
  year_beg <- min(data$year) - 1 
  
  # 各マーケットごとに限界費用計算する
  for (t in 1:T) {
    # あるマーケットの弾力性行列を取り出す
    elasmat_t <- elasticity[[t]] 
    
    # あるマーケットの大きさ(車種の数)
    J_t <- sum(marketindex == year_beg + t)
    
    # あるマーケットのデータを抽出
    data_t <- data[data$year == year_beg + t, ]
    
    # あるマーケットの価格とマーケットシェアを取り出す
    Pricevec_t <- data_t$price
    Sharevec_t <- data_t$share
    
    # 空の所有構造行列と弾力性の微分部分を用意する
    Ownership_t <- matrix(0, J_t, J_t)
    # 各弾力性に対して計算をする
    for (j in 1:J_t) {
      for (k in 1:J_t) {
        
        # 車種jと車種kが同じ企業で生産されていれば1を入れる
        if (data_t$Maker[j] == data_t$Maker[k]) {
          Ownership_t[j, k] <- 1
        }
      }
    }
    Derivative_t <- - (elasmat_t) * (kronecker(matrix(1, J_t, 1), t(Sharevec_t))) / 
      (kronecker(matrix(1, 1, J_t), Pricevec_t))
    # 所有構造行列に弾力性の微分部分を掛けることでDeltaを作成する
    Delta_t <- Derivative_t * Ownership_t
    
    # 限界費用を計算する
    Marginal_Cost_t <- Pricevec_t - (solve(Delta_t) %*% Sharevec_t)
    
    # データフレーム化してNameと企業名を追加する(NameIDはleft_joinに必要)
    Marginal_Cost_t_D <- data.frame(Name = data_t$Name, NameID = data_t$NameID, 
                                    Maker = data_t$Maker, 
                                    price = Pricevec_t, mc = Marginal_Cost_t) %>%
      mutate(margin = (price - mc) / price)
    # 限界費用をマーケットごとに名前を付けて保存する．
    MC_list[[t]] <- Marginal_Cost_t_D
    names(MC_list)[[t]] <- sprintf("Marginal_Cost_%d", t + year_beg)
  }
  return(MC_list)
}
```


作成した関数を使って限界費用を計算する。加えて価格費用マージンを計算してその分布を確認する。

```{r}
# 価格弾力性行列の計算。限界費用推定において用いる。
elasticity <- f_elasticity(datalist = datalist, parameter = parameter,
                           theta1 = theta1_hat, theta2 = theta2_hat, delta = delta)

# 作成した関数を実行する
marketindex <- datalist$marketindex
Marginal_Cost_Est <- f_Merginal_Cost_Est(data, marketindex, elasticity)

# 2016年の3つの企業のそれぞれの車種の限界費用を取り出す
# まず適当に3つの企業の名前を選ぶ
Maker <- unique(data$Maker)
Choice_Maker <- Maker[c(8, 10, 11)]

#2016年の限界費用を抽出
Marginal_Cost_2016_Est <- Marginal_Cost_Est$Marginal_Cost_2016

# Nevo (2000) Table 4
Table_4dt <-  Marginal_Cost_2016_Est %>%
  select(Maker, Name, price, mc, margin) %>%
  # この後の表記に合わせて企業名を、Honda=Nippyo, Nissan=Brand A, Subaru=Brand B, Toyota=Brand Cとする
  mutate(Maker = recode(Maker, Honda = "Nippyo", Nissan = "Brand_A", Subaru = "Brand_B", Toyota = "Brand_C"))
  
colnames(Table_4dt) <- c("Maker", "Name", "Price", "Marginal Cost", "Margin (p-mc)/p")

Table_4dt %>% 
  kable(align = rep("c", 5),
        digits = 3,
        booktabs = FALSE, format = "html",
        caption = "Predicted Marginal Costs") %>%
  kable_styling(full_width = FALSE)

# 表の保存
Table_4dt %>%
  kable(align = rep("c", 5),
        digits = 3,
        booktabs = FALSE, format = "latex",
        caption = "Predicted Marginal Costs") %>%
  kable_styling(full_width = FALSE) %>%
  save_kable("output/chap5_mc_2016.tex")
```

```{r}
# distribution of margin
g <- ggplot(Marginal_Cost_2016_Est, aes(x = margin)) + 
  geom_histogram(binwidth = 0.01) +
  theme_bw()
plot(g)
ggsave(g, file = "output/chap5_margin.png", width = 9, height = 6)
ggsave(g, file = "output/chap5_margin.pdf", width = 9, height = 6, device = cairo_pdf)
```

# 合併シミュレーション

需要推定結果を用いて、限界費用関数の推定及び合併シミュレーションを行う。

**留意点**: 第３章・ 第４章においては、日評自動車はランダムに選んだ車種を生産・販売していると考えたが、今回第５章ではホンダの車種を生産・販売する企業として扱う。


## 準備

2016年のみを取り出し、日評自動車（ホンダを日評自動車とする）と国内ブランドA社（日産を国内ブランドA社とする）、日評自動車と国内ブランドB社（スバルを国内ブランドB社とする）を合併した場合を考える。加えて比較のため国内ブランドC社を用意する（トヨタを国内ブランドC社とする）。

```{r}
# 最新の2016年のみ使用
data_2016 <-
  data %>%
  filter(year == 2016) %>%
  left_join(Marginal_Cost_2016_Est, by = c("NameID", "Maker", "Name", "price")) %>%
  # 企業名を変更する
  mutate(Maker = recode(Maker, Honda = "Nippyo", Nissan = "Brand_A", Subaru = "Brand_B", Toyota = "Brand_C")) %>%
  # 合併後の企業
  mutate(MakerNippyoA = recode(Maker, Nippyo = "Nippyo_A", Brand_A = "Nippyo_A"), 
         MakerNippyoB = recode(Maker, Nippyo = "Nippyo_B", Brand_B = "Nippyo_B"))
```

## 所有構造行列を作成する

日評自動車とブランドA社、日評自動車とブランドB社が合併した場合の所有構造行列を作成する。


```{r}
# ownership matrix
J <- sum(marketindex == 2016)
Ownership_NippyoA <- matrix(0, J, J)
Ownership_NippyoB <- matrix(0, J, J)
Ownership_true <- matrix(0, J, J)

for (j in 1:J) {
  for (k in 1:J) {
    if (data_2016$MakerNippyoA[j] == data_2016$MakerNippyoA[k]) {
      Ownership_NippyoA[j, k] <- 1
    }
    if (data_2016$MakerNippyoB[j] == data_2016$MakerNippyoB[k]) {
      Ownership_NippyoB[j, k] <- 1
    }
    if (data_2016$Maker[j] == data_2016$Maker[k]) {
      Ownership_true[j, k] <- 1
    }
  }
}
```

## BLP推定同様の下準備

```{r}
# 2016年に絞った状態で推定に必要な行列・リストを作成
datalist_2016 <- list()

# マーケットとモデルの情報をGET
N <- length(data_2016$year)
T <- length(unique(data_2016$year))

# 平均効用に入ってくる部分。内生性がある価格を含んでいる。
datalist_2016$X1 <- as.data.frame(datalist$X1) %>%
  mutate(year = datalist$marketindex) %>%
  filter(year == 2016) %>%
  select(-year) %>%
  as.matrix()

# ランダム係数とInteractする部分。
datalist_2016$X2 <- as.data.frame(datalist$X2) %>%
  mutate(year = datalist$marketindex) %>%
  filter(year == 2016) %>%
  select(-year) %>%
  as.matrix()

# 操作変数行列。ここは外生変数と追加的な操作変数を含む
datalist_2016$Z <-  as.data.frame(datalist$Z) %>%
  mutate(year = datalist$marketindex) %>%
  filter(year == 2016) %>%
  select(-year) %>%
  as.matrix()

# 市場シェア
datalist_2016$ShareVec <-
  data_2016 %>%
  select(share) %>%
  as.matrix()

datalist_2016$marketindex <- data_2016$year
datalist_2016$logitshare <- data_2016$logit_share
```

```{r}
# 乱数を用意
set.seed(111)

Nsim <- 1000

datalist_2016$draw_vec <- rnorm(Nsim * ncol(datalist_2016$X2))

parameter <- list()
parameter$Nsim <- Nsim

marketindex <- datalist_2016$marketindex
uniquemarketindex <- sort(unique(marketindex))
temp1 <- matrix(rep(uniquemarketindex, N), T, N) %>% t()
temp2 <- matrix(rep(marketindex, T), N, T)
mkt_denom_d <- (temp1 == temp2) * 1
datalist_2016$mkt_denom_d <- mkt_denom_d
```


## 反実仮想シミュレーションにおける均衡計算コード

合併後の価格を計算する。

```{r}
# 推定した費用を用いる
mc <- as.matrix(data_2016$mc)
# 残差として得られた観測されないXiは固定されているものとする
Xi <- as.matrix(data_2016$Xi)
```

ここでは合併後の所有構造に基づくベルトラン競争のナッシュ均衡を計算する。
方法については書籍4.3節を参照されたい。大枠の考え方は以下である。

1. ある価格ベクトル(p_oldと呼ぶ)を所与とする。
2. その価格のもとでの、各製品の最適反応価格を求める(この作業が以下の`f_update`関数)
3. その最適反応価格を新たな価格(p_new)とする。そのp_newに基づいて上のプロセスを再び行う。
4. 上記手順２と３を繰り返し、価格のアップデートがほとんど起きなくなったら、プロセスを止める。この作業が以下の`f_eqprice`で行われている。


```{r}
# 均衡を求める

# 価格をupdateする関数
f_update <- function(datalist, p_old, Ownership, parameter, theta1, theta2, mc, Xi) {
  
  # datalist内の価格を更新
  datalist$X1[, 'price'] <- as.matrix(p_old)
  datalist$X2 <- as.matrix(p_old)
  
  X1 <- datalist$X1
  
  # Market Shareを求める
  delta <- (X1 %*% theta1) + Xi
  Sharevec <- f_mktshare(datalist, parameter, delta, theta2)
  
  # elasticityを求める
  elas <- f_elasticity(datalist, parameter, theta1, theta2, delta)
  elasmat <- elas$elasmat_2016
  
  J <- length(p_old)
  Derivative <- - (elasmat) * (kronecker(matrix(1, J, 1), t(Sharevec))) / (kronecker(matrix(1, 1, J), p_old))
  Delta <- Ownership * Derivative
  p_new <- mc + (solve(Delta) %*% Sharevec)
  return(p_new)
}

# iterationで均衡価格を求める関数
f_eqprice <- function(datalist, p_ini, Ownership, parameter, theta1, theta2, mc, Xi) {
  
  # set the threshold
  lambda <- 1e-6
  p_old <- p_ini
  distance <- 10000
  while (distance > lambda) {
    p_new <- f_update(datalist, p_old, Ownership, parameter, theta1, theta2, mc, Xi)
    distance <- max(abs(p_new - p_old))
    p_old <- p_new
  }
  return(p_new)
}
```


## 合併シミュレーション

まず、日評自動車とA社が合併したケースのシミュレーションを行う。

```{r}
# Nippyo-Brand A Simulation
# set the initial price
p_ini <- data_2016$price
p_NippyoA <- f_eqprice(datalist_2016, p_ini, Ownership_NippyoA, parameter, theta1_hat, theta2_hat, mc, Xi)
data_2016 <- data_2016 %>%
  mutate(p_NippyoA = p_NippyoA[, 1])
```

つづいて、日評自動車とB社が合併したケースのシミュレーションを行う


```{r}
# Nippyo-Brand B Simulation
# set the initial price
p_ini <- data_2016$price
p_NippyoB <- f_eqprice(datalist_2016, p_ini, Ownership_NippyoB, parameter, theta1_hat, theta2_hat, mc, Xi)
data_2016 <- data_2016 %>%
  mutate(p_NippyoB = p_NippyoB[, 1])
```

```{r}
# シミュレートされた価格でのシェアを与える関数
f_mktshare_sim <- function(datalist, p, parameter, theta1, theta2, Xi) {
  
  # datalist内の価格を更新
  datalist$X1[, 'price'] = p
  datalist$X2 = p
  X1 = datalist$X1
  
  # Market Shareを求める
  delta = (X1 %*% theta1) + Xi
  Sharevec = f_mktshare(datalist, parameter, delta, theta2)
  
  return(Sharevec)
}
```

合併後の価格からそれぞれの車種のマーケットシェアを計算する。

```{r}
# 合併時のシェアを計算
share_NippyoA <- f_mktshare_sim(datalist_2016, data_2016$p_NippyoA, parameter, theta1_hat, theta2_hat, Xi)
share_NippyoB <- f_mktshare_sim(datalist_2016, data_2016$p_NippyoB, parameter, theta1_hat, theta2_hat, Xi)

data_2016 <- data_2016 %>%
  mutate(share_NippyoA = share_NippyoA, share_NippyoB = share_NippyoB)
```

# シミュレーション結果のまとめ

## 合併シミュレーションによる価格・販売台数変化

なお、この表はNevo(2000, RAND)のTABLE 5と同様。（比較対象として国内ブランドC社（トヨタを国内ブランドC社とする）を表に含む）

```{r}
# 表を作るために専用のデータフレームを作る
Table_5dt <- data_2016 %>%
  mutate(p_NippyoA_PPC = (p_NippyoA - price) / price * 100,
         share_NippyoA_PPC = (share_NippyoA - share) / share * 100,
         p_NippyoB_PPC = (p_NippyoB - price) / price * 100,
         share_NippyoB_PPC = (share_NippyoB - share) / share * 100) %>%
  select(Maker, Name, p_NippyoA_PPC, share_NippyoA_PPC, p_NippyoB_PPC,
         share_NippyoB_PPC) %>%
  filter(Maker %in% c("Nippyo","Brand_A","Brand_B","Brand_C"))

# 名前を付けなおす
colnames(Table_5dt) <- c("Maker", "Name", "p", "q", "p", "q")

# 表を作る
Table_5dt %>%
  kable(align = rep("c", 6),
        digits = 3,
        booktabs = FALSE, format = "html", 
        caption = "Predicted Percent Change in Prices and Quantities as a Result of Mergers") %>%
  add_header_above(c(" ", " ", "Nippyo and Brand A" = 2, "Nippyo and Brand B" = 2)) %>%
  kable_styling(full_width = FALSE)

# 表の保存
Table_5dt %>%
  kable(align = rep("c", 6),
        digits = 3,
        booktabs = FALSE, format = "latex", 
        caption = "Predicted Percent Change in Prices and Quantities as a Result of Mergers") %>%
  add_header_above(c(" ", " ", "Nippyo and Brand A" = 2, "Nippyo and Brand B" = 2)) %>%
  kable_styling(full_width = FALSE) %>%
  save_kable("output/chap5_merger_change_p_q.tex")
```


## 日評自動車とブランドAの合併後に価格が変化しないような限界費用を計算する

ここでは、需要推定値・シェア・価格はデータ上のものに固定した上で、「日評自動車とA社が合併していて共同利潤最大化していた場合」における限界費用を計算している。

このようにして得られた限界費用の元では、「日評自動車とA社」が合併した場合に利潤最大化するような価格というものは、データ上の価格と一致（すなわち価格が変化しない）することとなる。


```{r}
# 合併前の弾力性行列
elasmat_2016 <- list(elasticity$elasmat_2016)

# 日評自動車とブランドA社の名前を同じにする（所有構造を変更）
data_2016_NippyoA <- data_2016 %>%
  mutate(Maker = MakerNippyoA) %>%
  select(year, Maker, Name, NameID, price, share)

# 限界費用を計算（シェアと価格、弾力性は合併以前のものを使用）
mc_NippyoA_pfix <- f_Merginal_Cost_Est(data_2016_NippyoA, marketindex, elasmat_2016)
mc_NippyoA_pfix_2016 <- mc_NippyoA_pfix$Marginal_Cost_2016
data_2016 <- data_2016 %>%
  mutate(mc_NippyoA_pfix = mc_NippyoA_pfix_2016$mc)
```

## 日評自動車とブランドBの合併後に価格が変化しないような限界費用を計算する

考え方は上と同様。

```{r}
# 日評自動車とブランドB社の名前を同じにする（所有構造を変更）
data_2016_NippyoB <- data_2016 %>%
  mutate(Maker = MakerNippyoB) %>%
  select(year, Maker, Name, NameID, price, share)

# 限界費用を計算（シェアと価格、弾力性は合併以前のものを使用）
mc_NippyoB_pfix <- f_Merginal_Cost_Est(data_2016_NippyoB, marketindex, elasmat_2016)
mc_NippyoB_pfix_2016 <- mc_NippyoB_pfix$Marginal_Cost_2016
data_2016 <- data_2016 %>%
  mutate(mc_NippyoB_pfix = mc_NippyoB_pfix_2016$mc)
```

以上の結果に基づき、合併による価格上昇を打ち消すのに必要な限界費用変化を求めることができる。

```{r}
# 表を作るために専用のデータフレームを作る
Table_6dt <- data_2016 %>%
  mutate(mc_NippyoA_PPC = (mc_NippyoA_pfix - mc) / mc * 100,
         mc_NippyoB_PPC = (mc_NippyoB_pfix - mc) / mc * 100) %>%
  select(Maker, Name, mc_NippyoA_PPC, mc_NippyoB_PPC) %>%
  filter(Maker %in% c("Nippyo","Brand_A","Brand_B","Brand_C"))

# 名前を付けなおす
colnames(Table_6dt) <- c("Origin Maker", "Name", "Nippyo and Brand A",
                         "Nippyo and Brand B")

# 表を作る
Table_6dt %>%
  kable(align = rep("c", 4),
        digits = 3,
        booktabs = FALSE, format = "html", 
        caption = "Percent Reduction in Marginal Costs Required for No Change in Predicted Postmerger Prices") %>%
  kable_styling(full_width = FALSE)

# 表の保存
Table_6dt %>%
  kable(align = rep("c", 4),
        digits = 3,
        booktabs = FALSE, format = "latex", 
        caption = "Percent Reduction in Marginal Costs Required for No Change in Predicted Postmerger Prices") %>%
  kable_styling(full_width = FALSE) %>%
  save_kable("output/chap5_merger_change_mc.tex")
```

## 合併シミュレーションの厚生分析

ある個人$i$の補償変分（CV）は以下の式で求められる。

$$
CV_i = \frac{\ln(\sum^J_{j=0}\exp(V^{post}_{ij})) - \ln(\sum^J_{j=0}\exp(V^{pre}_{ij}))}{\alpha_i}
$$
まず、消費者余剰を推定する関数を用意する。

```{r}
# Nevo (2000) 式(6), (7)参照
# p.414に従いdrawの中でCV_iの平均を取ってから消費者数を乗する

# consumer surplusを計算する関数
# see Small and Rosen (1981), ignoring an unknown constant term
# see also Tran (2009) "Discrete Choice Methods with Simulation" Chapter 3
f_CS = function(datalist, p, parameter, theta1, theta2, Xi, HH) {
  # datalist内の価格を更新
  datalist$X1[, 'price'] <- p
  datalist$X2 <- as.matrix(p)
  X1 <- datalist$X1
  
  # deltaを求める
  delta <- (X1 %*% theta1) + Xi
  
  # f_mktshareの分子と同じ計算
  X2 <- datalist$X2
  N <- length(datalist$marketindex)
  draw_vec <- datalist$draw_vec
  marketindex <- datalist$marketindex
  mkt_denom_d <- datalist$mkt_denom_d
  Nsim <- parameter$Nsim
  K2 <- length(theta2)
  # Nonlinear component. mu (N, ns) matrix.
  mu <- X2 %*% diag(x = theta2, nrow = K2) %*% matrix(draw_vec, nrow = K2)
  
  # prepare exp_V
  V <- delta %*% matrix(1, nrow = 1, ncol = Nsim) + mu
  exp_V <- exp(V)
  # numerator
  # the second term is for the outside good
  numerator <- log(colSums(exp_V) + exp(matrix(0, 1, Nsim)))
  
  # Price parameter alpha_i
  draw_for_price <- matrix(draw_vec, nrow = K2)[1, ]
  # theta1のなかで2つ目、theta2のなかで1つ目に価格係数がある
  alpha_i <- - (theta1[2] + theta2[1] * draw_for_price)
  
  # Consumer Surplus
  CS <- mean(numerator / alpha_i) * HH
  return(CS)
}
```

消費者余剰と補償変分を求める。

```{r}
# compensating variation
HH_2016 <- unique(data_2016$HH)
CS_2016 <- f_CS(datalist_2016, data_2016$price, parameter, theta1_hat, theta2_hat, Xi, HH_2016)
CS_NippyoA <- f_CS(datalist_2016, data_2016$p_NippyoA, parameter, theta1_hat, theta2_hat, Xi, HH_2016)
CS_NippyoB <- f_CS(datalist_2016, data_2016$p_NippyoB, parameter, theta1_hat, theta2_hat, Xi, HH_2016)

CV_NippyoA <- CS_NippyoA - CS_2016
CV_NippyoB <- CS_NippyoB - CS_2016
```

次に企業の利潤を計算する。ある企業$f$の利潤の式は

$$ \sum_{j \in \mathcal{F}_f} (p_j - mc_j)q_j(\mathbf{p}) $$
である。ここでpは価格、mcは限界費用、qは数量（ここではシェアに家計の数を掛けることで求める）である。


```{r}
# Profit and Revenue
f_profit <- function(Maker, price, mc, share, HH) {
  pro_rev_dt <- data.frame(Maker, 
                           profit_each = (price - mc) * share * HH,
                           revenue_each = price * share * HH)
  pro_rev <- pro_rev_dt %>%
    group_by(Maker) %>%
    summarise(profit = sum(profit_each), revenue = sum(revenue_each)) %>%
    ungroup() %>%
    as.data.frame()
  return(pro_rev)
}
```

総余剰の変化を導出する。

```{r}
pro_rev_2016 <- f_profit(data_2016$Maker, data_2016$price, data_2016$mc, data_2016$share, HH_2016)  

pro_rev_NippyoA <- f_profit(data_2016$Maker, data_2016$p_NippyoA, data_2016$mc,
                            data_2016$share_NippyoA, HH_2016) 

pro_rev_NippyoB <- f_profit(data_2016$Maker, data_2016$p_NippyoB, data_2016$mc,
                            data_2016$share_NippyoB, HH_2016) 

# Total Surplus Change
TS_Chage_NippyoA <- CV_NippyoA + sum(pro_rev_NippyoA$profit - pro_rev_2016$profit)
TS_Chage_NippyoB <- CV_NippyoB + sum(pro_rev_NippyoB$profit - pro_rev_2016$profit)
```

消費者余剰と総余剰の変化の表を作成

```{r}
Table_7dt1 <- tibble(
  clo1 = c("Consumer surplus", "Total Welfare"),
  col2 = c(CV_NippyoA, TS_Chage_NippyoA),
  col3 = c(CV_NippyoB, TS_Chage_NippyoB)
)

colnames(Table_7dt1) <- c("Measure", "Nippyo and Brand A",
                          "Nippyo and Brand B")
Table_7dt1 %>%
  kable(align = rep("c", 3), 
        digits = 1,
        booktabs = FALSE, format = "html",
        caption = "Consumer Surplus and Welfare") %>%
  kable_styling(full_width = FALSE)

# 表の保存
Table_7dt1 %>%
  kable(align = rep("c", 3), 
        digits = 1,
        booktabs = FALSE, format = "latex",
        caption = "Consumer Surplus and Welfare") %>%
  kable_styling(full_width = FALSE) %>%
  save_kable("output/chap5_merger_welfare.tex")
```

表を作る前の下準備をする関数を作成

```{r}
gen_pro_rev_table <- function(pro_rev_2016, pro_rev_NippyoA, pro_rev_NippyoB) {
  result_df <- tibble(
    Maker = pro_rev_2016$Maker,
    col2 = pro_rev_NippyoA$profit - pro_rev_2016$profit,
    col3 = pro_rev_NippyoA$revenue - pro_rev_2016$revenue,
    col4 = pro_rev_NippyoB$profit - pro_rev_2016$profit,
    col5 = pro_rev_NippyoB$revenue - pro_rev_2016$revenue
    ) 
  
  Total <- tibble(Maker = "Total",
                  col2 = sum(result_df$col2),
                  col3 = sum(result_df$col3),
                  col4 = sum(result_df$col4),
                  col5 = sum(result_df$col5))
  result_df <- rbind(result_df, Total)
  
  colnames(result_df) <- c("Maker", "Profits", "Revenues", "Profits", "Revenues")
  
  return(result_df)
}
```

合併前と合併後の収入を比較する表を作成
（表中の企業名は日評自動車としているホンダ、ブランドA社としている日産、ブランドB社としているスバル、ブランドC社としているトヨタ以外はそのままの社名を使っている。）

```{r}
Table_7dt2 <- gen_pro_rev_table(pro_rev_2016, pro_rev_NippyoA, pro_rev_NippyoB)

# 表を作る
Table_7dt2 %>%
  kable(align = rep("c", 5),
        digits = 1,
        booktabs = FALSE, format = "html",
        caption = "Change in Profits and Revenues") %>%
  add_header_above(c(" ", "Nippyo and Brand A" = 2, "Nippyo and Brand B" = 2)) %>%
  kable_styling(full_width = FALSE)
# 表の保存
Table_7dt2 %>%
  kable(align = rep("c", 5),
        digits = 1,
        booktabs = FALSE, format = "latex",
        caption = "Change in Profits and Revenues") %>%
  add_header_above(c(" ", "Nippyo and Brand A" = 2, "Nippyo and Brand B" = 2)) %>%
  kable_styling(full_width = FALSE) %>%
  save_kable("output/chap5_merger_revenue.tex")
```


## シミュレーションに関する計算時間

最後に、ここまでの計算にかかった合計時間をレポートする。

```{r}
tictoc::toc()
```




# Appendix 1: 追加的なシミュレーション

ここでは「総余剰が変化しない」ために要求される合併企業の限界費用削減について計算しよう。

なお、Appendix 1の分析については比較的計算時間がかかる(パソコンのスペックにもよるが10-20分程度)ので、その点留意されたい。
ここでも`tictoc`で計算時間を計測しよう。

```{r}
tictoc::tic()
```


## 関数の定義：総余剰が変化しないような限界費用削減

```{r}
# 特定の企業のみ限界費用を定数倍した時の、総余剰の変化を関数
f_effect_cost_reduction <- function(cost_red, cost_red_firm, Ownership, data, datalist, 
                                    parameter, theta1, theta2, HH, p_pre, pro_rev_pre, CS_pre) {
  # 特定の企業のみ、限界費用を一律に係数倍
  data <- data %>%
    mutate(mc = if_else(Maker %in% cost_red_firm, mc * cost_red, mc))
  mc <- data$mc
  
  # 均衡価格
  p_post <- f_eqprice(datalist, p_pre, Ownership, parameter, theta1, theta2, mc, Xi)
  
  # CVの計算
  CV <- (f_CS(datalist, p_post, parameter, theta1, theta2, Xi, HH) - CS_pre)
  # 利益と売上の計算
  share_post <- f_mktshare_sim(datalist, p_post, parameter, theta1, theta2, Xi)
  pro_rev_post <- f_profit(data$Maker, p_post, data$mc, share_post, HH) 
  
  # 総余剰の変化
  TS_Chage <- CV + sum(pro_rev_post$profit - pro_rev_pre$profit)
  obj <- TS_Chage
  return(obj)
}
```

## 日評自動車とブランドAについて限界費用削減を計算

```{r}
# Nippyo-Brand A 限界費用削減
# cost_redについて総余剰変化は単調減少するため、二分法を適用

# 両企業が限界費用削減 （日評自動車とbrand Aを取り出す）
cost_red_firm <- c("Nippyo", "Brand_A")

distance <- 100
lambda <- 10^(-6)
max_cost_red <- 1
min_cost_red <- 0

# ここのループにおいて、総余剰を合併前の水準に保つために必要な限界費用削減率を計算している。
while (distance > lambda) {
  mid_cost_red <- (max_cost_red + min_cost_red) / 2

  mid_eval <- f_effect_cost_reduction(
    cost_red = mid_cost_red, 
    cost_red_firm = cost_red_firm, 
    Ownership = Ownership_NippyoA,
    data = data_2016, 
    datalist = datalist_2016,  
    parameter = parameter, 
    theta1 = theta1_hat,
    theta2 = theta2_hat,
    HH = HH_2016, 
    p_pre = data_2016$p_NippyoA,
    pro_rev_pre = pro_rev_2016,
    CS_pre = CS_2016)

  if (mid_eval > 0) {
    min_cost_red <- mid_cost_red
  } else {
    max_cost_red <- mid_cost_red
  }
  
  distance <- abs(mid_eval - 0)
  print(distance)
}

cost_red_NippyoA <- mid_cost_red

data_2016 <- data_2016 %>%
  mutate(mc_NippyoA_TSfix = if_else(Maker %in% cost_red_firm, mc * cost_red_NippyoA, mc))

p_NippyoA_TSfix <- f_eqprice(datalist_2016,data_2016$p_NippyoA,Ownership_NippyoA,
                             parameter, theta1_hat, theta2_hat, data_2016$mc_NippyoA_TSfix, Xi)
share_NippyoA_TSfix <- f_mktshare_sim(datalist_2016, p_NippyoA_TSfix, parameter, theta1_hat, theta2_hat, Xi)
data_2016 <- data_2016 %>%
  mutate(p_NippyoA_TSfix = p_NippyoA_TSfix, share_NippyoA_TSfix = share_NippyoA_TSfix)
```

## 日評自動車とブランドBについて限界費用削減を計算

```{r}
# Nippyo-Brand B 限界費用削減
# cost_redについて総余剰変化は単調減少するため、二分法を適用

# 両企業が限界費用削減 （日評自動車とbrand Bを取り出す）
cost_red_firm <- c("Nippyo","Brand_B")

distance <- 100
lambda <- 10^(-6)
max_cost_red <- 1
min_cost_red <- 0

# ここのループにおいて、総余剰を合併前の水準に保つために必要な限界費用削減率を計算している。
while (distance > lambda){
  mid_cost_red <- (max_cost_red + min_cost_red) / 2
  mid_eval <- f_effect_cost_reduction(
    cost_red = mid_cost_red, 
    cost_red_firm = cost_red_firm,
    Ownership = Ownership_NippyoB,
    data = data_2016, 
    datalist = datalist_2016,  
    parameter = parameter,
    theta1 = theta1_hat,
    theta2 = theta2_hat,
    HH = HH_2016, 
    p_pre = data_2016$p_NippyoB,
    pro_rev_pre = pro_rev_2016,
    CS_pre = CS_2016)
  
  if (mid_eval > 0) {
    min_cost_red <- mid_cost_red
  } else {
    max_cost_red <- mid_cost_red
  }
  
  distance <- abs(mid_eval - 0)
  print(distance)
}

cost_red_NippyoB <- mid_cost_red

data_2016 <- data_2016 %>%
  mutate(mc_NippyoB_TSfix = if_else(Maker %in% cost_red_firm, mc * cost_red_NippyoB, mc))

p_NippyoB_TSfix <- f_eqprice(datalist_2016, data_2016$p_NippyoB, Ownership_NippyoB,
                             parameter, theta1_hat, theta2_hat, data_2016$mc_NippyoB_TSfix, Xi)

share_NippyoB_TSfix <- f_mktshare_sim(datalist_2016, p_NippyoB_TSfix, parameter, theta1_hat, theta2_hat, Xi)

data_2016 <- data_2016 %>%
  mutate(p_NippyoB_TSfix = p_NippyoB_TSfix, share_NippyoB_TSfix = share_NippyoB_TSfix)

print(cost_red_NippyoB)
```

## 限界費用削減の表を作成

```{r}
Table_7dt3 <- tibble(
  col1 = c("Cost reduction"),
  col2 = (1 - cost_red_NippyoA) * 100,
  col3 = (1 - cost_red_NippyoB) * 100
  )

colnames(Table_7dt3) <- c("Measure", "Nippyo and Brand A",
                          "Nippyo and Brand B")

Table_7dt3 %>%
  kable(align = rep("c", 3),
        digits = 2,
        booktabs = FALSE, format = "html",
        caption = "Cost Reduction (Percent)") %>% 
  kable_styling(full_width = FALSE)

# 表の保存
Table_7dt3 %>%
  kable(align = rep("c", 3),
        digits = 2,
        booktabs = FALSE, format = "latex",
        caption = "Cost Reduction (Percent)") %>% 
  kable_styling(full_width = FALSE) %>%
  save_kable("output/chap5_appendix_merger_mc.tex")
```

## 限界費用削減をした場合の利潤と収入の変化
（表中の企業名は日評自動車としているホンダ、ブランドA社としている日産、ブランドB社としているスバル、ブランドC社としているトヨタ以外はそのままの社名を使っている。）

```{r}
# 日評自動車とブランドA社が合併した場合の利益の導出
pro_rev_NippyoA_rc <- f_profit(data_2016$Maker, data_2016$p_NippyoA_TSfix, data_2016$mc_NippyoA_TSfix,
                               data_2016$share_NippyoA_TSfix, HH_2016) 

# 日評自動車とブランドB社が合併した場合の利益の導出
pro_rev_NippyoB_rc <- f_profit(data_2016$Maker, data_2016$p_NippyoB_TSfix, data_2016$mc_NippyoB_TSfix,
                               data_2016$share_NippyoB_TSfix, HH_2016) 

Table_7dt4 <- gen_pro_rev_table(pro_rev_2016, pro_rev_NippyoA_rc, pro_rev_NippyoB_rc)

# 表を作る
Table_7dt4 %>%
  kable(align = rep("c", 5),
        digits = 2,
        booktabs = FALSE, format = "html",
        caption = "Change in Profits and Revenues") %>% 
  add_header_above(c(" ", "Nippyo and Brand A" = 2, "Nippyo and Brand B" = 2)) %>%
  kable_styling(full_width = FALSE)

# 表の保存
Table_7dt4 %>%
  kable(align = rep("c", 5),
        digits = 2,
        booktabs = FALSE, format = "latex",
        caption = "Change in Profits and Revenues") %>% 
  add_header_above(c(" ", "Nippyo and Brand A" = 2, "Nippyo and Brand B" = 2)) %>%
  kable_styling(full_width = FALSE) %>%
  save_kable("output/chap5_appendix_merger_revenue.tex")
```

## 限界費用削減をした場合の全体の利潤と収入の変化率

```{r}
print((sum(pro_rev_NippyoA_rc$profit) - sum(pro_rev_2016$profit)) / sum(pro_rev_2016$profit) * 100)
print((sum(pro_rev_NippyoA_rc$revenue) - sum(pro_rev_2016$revenue)) / sum(pro_rev_2016$revenue) * 100)
print((sum(pro_rev_NippyoB_rc$profit) - sum(pro_rev_2016$profit)) / sum(pro_rev_2016$profit) * 100)
print((sum(pro_rev_NippyoB_rc$revenue) - sum(pro_rev_2016$revenue)) / sum(pro_rev_2016$revenue) * 100)
```

## 計算時間レポート

Appendix 1にかかった合計計算時間をレポートする。

```{r}
tictoc::toc()
```