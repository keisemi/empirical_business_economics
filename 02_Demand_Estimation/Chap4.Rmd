---
title: "「実証ビジネス・エコノミクス」 第４章 <br> 「プライシングの真髄は代替性にあり：消費者需要モデルの推定［基礎編2］」"
author: "上武康亮・遠山祐太・若森直樹・渡辺安虎"
date: '最終更新: `r Sys.Date()`'
output:
  html_document: 
    code_folding: show
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# はじめに

「実証ビジネス・エコノミクス」の第４章「プライシングの真髄は代替性にあり：消費者需要モデルの推定［基礎編2］」に関するRプログラムの紹介である。本プログラムによってざ誌面で紹介した分析を再現しつつ、実際に手を動かしながら学ぶことを目的とする。


## 留意事項

1. 本連載の内容、およびサンプルコード等の資料は、情報の提供のみを目的としていますので、運用につきましては十分にご確認をいただき、お客様ご自身の責任とご判断によって行ってください。これらの情報の運用結果により損害等が生じた場合でも、日本評論社および著者はいかなる責任を負うことはできませんので、ご留意ください。


## 全体の流れ

1.  下準備：パッケージの導入
2.  データの読み込み、クリーニング
3.  記述統計の作成
4.  ロジットモデルの推定
5.  推定結果に基づくエクササイズ

## 謝辞

前回に引き続いて藤田光明さん(サイバーエージェント)・哥丸連太朗さん(東京大学大学院経済学研究科)、
また今回のプログラムのチェックに島本幸典さん・牧野圭吾さん・山田雅広さん(東京大学大学院経済学研究科)にご尽力頂きました。


# Rに関する下準備

```{r}
# ワークスペースを初期化
rm(list = ls())

# パッケージを読み込む。
require(tidyverse)
require(fixest)
require(summarytools)
require(sjmisc)
require(kableExtra)
```


# データの準備

一気に前回の作業を読み込む。

```{r}
# まず自動車データを読み込む
data <- readr::read_csv(file = "data/CleanData_20180222_nippyo.csv")

# 続いて、家計数データ（潜在的な市場規模）を読み込む。ソースは以下。 <https://www.airia.or.jp/publish/file/r5c6pv0000006s9v-att/r5c6pv0000006saa.pdf>
dataHH <- readr::read_csv(file = "data/HHsize.csv")

# 価格を実質化するべく、消費者物価指数を読み込む
# ソースは以下：<https://www.e-stat.go.jp/stat-search/file-download?statInfId=000031431770&fileKind=1>

dataCPI <- readr::read_csv(file = "data/zni2015s.csv", locale = locale(encoding = "shift-jis"))

dataCPI <- dataCPI[6:56, ]
dataCPI <- dataCPI %>% 
  dplyr::rename(year = '類・品目',
                cpi = '総合') %>% 
  dplyr::select(year, cpi) %>% 
  dplyr::mutate(
    year = as.numeric(year), 
    cpi = as.numeric(cpi)
  )

## データクリーニング
# まずは、自動車データを整理しつつ、家計データをマージする
# 必要な変数のみをキープ
data <- data %>%
  dplyr::select(
    Maker, Type, Name, Year, Sales, Model, Nippyo, price, kata,
    weight, capacity, FuelType, FuelEfficiency, HorsePower,
    overall_length, overall_width, overall_height
    ) %>%
  dplyr::rename(year = Year)

# 家計サイズをマージする。
data <- data %>%
  dplyr::left_join(dataHH, by = "year")

# CPIをマージする
data <- data %>% 
  dplyr::left_join(dataCPI, by = "year") 

# 燃費が欠損しているデータがある。今回は簡便な処理として観測から落とす。
data <- data %>%
  dplyr::filter(is.na(FuelEfficiency) == 0)

# 価格の実質化を行う。ここでは、2016年を基準年とする
# また、価格の単位を100万円にする。元のデータは1万円
cpi2016 <- dataCPI %>% 
  dplyr::filter(year == 2016) %>% 
  dplyr::select(cpi) %>% 
  as.double()

data <- data %>% 
  dplyr::mutate(price = price / (cpi / cpi2016)) %>% 
  dplyr::mutate(price = price / 100) %>%
  dplyr::select(-cpi) 

# サイズ(高さ＊幅＊長さ)、燃費の重量に対する比率を定義する
data <- data %>%
  dplyr::mutate(size = (overall_length / 1000) * (overall_width / 1000) * (overall_height / 1000)) %>%
  dplyr::mutate(hppw = HorsePower / weight) %>%
  dplyr::select(-HorsePower, -weight) %>% 
  dplyr::select(-starts_with("overall")) 

# 自動車の車種IDを作成する
data <- data %>%
  dplyr::group_by(Name) %>%
  dplyr::mutate(NameID = dplyr::cur_group_id()) %>%
  dplyr::ungroup() %>%
  dplyr::relocate(NameID, year)

# マーケットシェアとOutside option shareを定義する
data <- data %>%
  dplyr::group_by(year) %>%
  dplyr::mutate(inside_total = sum(Sales)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(outside_total = HH - inside_total) %>%
  dplyr::mutate(share = Sales / HH) %>%
  dplyr::mutate(share0 = outside_total / HH) %>%
  dplyr::select(-inside_total, -outside_total)

# 操作変数の構築
# まず、マーケット・企業レベルにおける、各製品属性の和と自乗和を計算する。
# ここでacross関数は、最初に文字列ベクトルで指定した変数について、後ろにリスト内で定義した操作を適用している。
data <- data %>%
  dplyr::group_by(year, Maker) %>%
  dplyr::mutate(
    dplyr::across(c("hppw", "FuelEfficiency", "size"),
                  list(sum_own = ~ sum(.x, na.rm = TRUE))),
    dplyr::across(c("hppw", "FuelEfficiency", "size"),
                  list(sqr_sum_own = ~ sum(.x^2, na.rm = TRUE))),
    group_n = n()
  ) %>%
  dplyr::ungroup()

# 次に、マーケットレベルでの、各製品属性の和を計算する。
data <- data %>% 
  dplyr::group_by(year) %>%
  dplyr::mutate( 
    dplyr::across(c("hppw", "FuelEfficiency", "size"),
                  list(sum_mkt = ~ sum(.x, na.rm = TRUE))),
    dplyr::across(c("hppw", "FuelEfficiency", "size"),
                  list(sqr_sum_mkt = ~ sum(.x^2, na.rm = TRUE))),
    mkt_n = n()
  ) %>%
  dplyr::ungroup() 

# 以上で定義した変数を利用して、まずBLP操作変数を構築する。
data <- data %>% 
  dplyr::mutate(
    iv_BLP_own_hppw = hppw_sum_own - hppw,
    iv_BLP_own_FuelEfficiency = FuelEfficiency_sum_own - FuelEfficiency,
    iv_BLP_own_size = size_sum_own - size,
    iv_BLP_other_hppw = hppw_sum_mkt - hppw_sum_own,
    iv_BLP_other_FuelEfficiency = FuelEfficiency_sum_mkt - FuelEfficiency_sum_own,
    iv_BLP_other_size = size_sum_mkt - size_sum_own, 
    iv_BLP_own_num = group_n - 1, 
    iv_BLP_other_num = mkt_n - group_n
  ) 

# 続いて、Differentiation IVを構築する。
data <- data %>% 
  dplyr::mutate(
    iv_GH_own_hppw = (group_n - 1) * hppw^2 + (hppw_sqr_sum_own - hppw^2) - 2 * hppw * (hppw_sum_own - hppw),
    iv_GH_own_FuelEfficiency = (group_n - 1) * FuelEfficiency^2 +
      (FuelEfficiency_sqr_sum_own - FuelEfficiency^2) - 2 * FuelEfficiency * (FuelEfficiency_sum_own - FuelEfficiency),
    iv_GH_own_size = (group_n - 1) * size^2 + (size_sqr_sum_own - size^2) - 2 * size * (size_sum_own - size),
    iv_GH_other_hppw = (mkt_n - group_n) * hppw^2 + (hppw_sqr_sum_mkt - hppw_sqr_sum_own) - 2 * hppw * (hppw_sum_mkt - hppw_sum_own),
    iv_GH_other_FuelEfficiency = (mkt_n - group_n) * FuelEfficiency^2 +
      (FuelEfficiency_sqr_sum_mkt - FuelEfficiency_sqr_sum_own) - 2 * FuelEfficiency * (FuelEfficiency_sum_mkt - FuelEfficiency_sum_own),
    iv_GH_other_size = (mkt_n - group_n) * size^2 + (size_sqr_sum_mkt - size_sqr_sum_own) - 2 * size * (size_sum_mkt - size_sum_own)
  ) %>%
  dplyr::select(
    -starts_with("sum_own"),
    -starts_with("sum_mkt"),
    -starts_with("sqr_sum_own"),
    -starts_with("sqr_sum_mkt"),
    -mkt_n,
    -group_n
  )　
```

# Logitモデルにおける価格弾力性
## イントロダクションの日評自動車

まず前回同様、日評自動車のデータセットを用意する。

```{r}
# 日評自動車のデータセットを作成する
data_NIPPYO <- data %>% 
  dplyr::filter(Nippyo == 1) %>% 
  dplyr::select(year, share, NameID, Sales, price, hppw, FuelEfficiency, size, Name) %>% 
  dplyr::mutate(
    log_sales = log(Sales),
    log_price = log(price)
  )
```


## 価格弾力性行列を作成する

```{r}
data <- data %>%
  dplyr::mutate(logit_share = log(share) - log(share0))

# Differentiation IVを用いた結果
iv_GH <- fixest::feols(
  logit_share ~ hppw + FuelEfficiency + size | 0 |
    price ~ iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size +
    iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size,
  data = data
)

dt2016 <- data_NIPPYO %>% 
  dplyr::filter(year == 2016) %>% 
  dplyr::select(price, share, NameID, Name) %>% 
  dplyr::arrange(NameID)

price <- dt2016$price
share <- dt2016$share
NameID <- dt2016$NameID

own_elas <- iv_GH$coefficients["fit_price"] * price * (1 - share)

cross_elas <- (-1) * iv_GH$coefficients["fit_price"] * price * share
J <- length(own_elas)

elas_mat <- matrix(rep(cross_elas, J), nrow = J, ncol = J)
diag(elas_mat) <- own_elas
```


表１の価格弾力性行列。以下の製品について見る。

- ベータード, セダン(A), SUV(B), 軽自動車(C)

```{r}
betard <- dt2016 %>%
  dplyr::filter(Name == "アルファード") %>%
  dplyr::pull(NameID)

sedan <- dt2016 %>%
  dplyr::filter(Name == "カローラ") %>%
  dplyr::pull(NameID)

suv <- dt2016 %>%
  dplyr::filter(Name == "ジューク") %>%
  dplyr::pull(NameID)

kei <- dt2016 %>%
  dplyr::filter(Name == "タント") %>%
  dplyr::pull(NameID)

elas_mat_restricted <- elas_mat[NameID %in% c(betard, sedan, suv, kei), NameID %in% c(betard, sedan, suv, kei)]
Name <- c("ベータード", "セダン(A)", "SUV(B)", "軽自動車(C)")
colnames(elas_mat_restricted) <- Name
rownames(elas_mat_restricted) <- Name

elas_mat_restricted %>%
  knitr::kable(
    align = rep("c", 4),
    digits = 4,
    booktabs = FALSE,
    format = "html"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE)

# 表の保存
elas_mat_restricted %>%
  knitr::kable(
    align = rep("c", 4),
    digits = 4,
    booktabs = FALSE,
    format = "latex"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::save_kable("output/chap4_elas_mat_logit.tex")
```


# 入れ子型ロジット推定のためのBLP操作変数の作成

```{r}
# まず、マーケット・企業レベルにおける、各製品属性の和と自乗和を計算する
# ここでacross関数は、最初に文字列ベクトルで指定した変数について、後ろにリスト内で定義した操作を適用している
data <- data %>%
  dplyr::group_by(year, Maker, Type) %>%
  dplyr::mutate(
    dplyr::across(c("hppw", "FuelEfficiency", "size"),
                  list(sum_own = ~ sum(.x, na.rm = TRUE))),
    dplyr::across(c("hppw", "FuelEfficiency", "size"),
                  list(sqr_sum_own = ~ sum(.x^2, na.rm = TRUE))),
    group_n = n()
  ) %>%
  dplyr::ungroup()

# 次に、マーケットレベルでの、各製品属性の和を計算する
data <- data %>% 
  dplyr::group_by(year, Type) %>%
  dplyr::mutate( 
    dplyr::across(c("hppw", "FuelEfficiency", "size"),
                  list(sum_mkt = ~ sum(.x, na.rm = TRUE))),
    dplyr::across(c("hppw", "FuelEfficiency", "size"),
                  list(sqr_sum_mkt = ~ sum(.x^2, na.rm = TRUE))),
    mkt_n = n()
  ) %>%
  dplyr::ungroup() 

# 以上で定義した変数を利用して、まずBLP操作変数を構築する。
data <- data %>% 
  dplyr::mutate(
    iv_BLP_own_hppw_nest = hppw_sum_own - hppw,
    iv_BLP_own_FuelEfficiency_nest = FuelEfficiency_sum_own - FuelEfficiency,
    iv_BLP_own_size_nest = size_sum_own - size,
    iv_BLP_other_hppw_nest = hppw_sum_mkt - hppw_sum_own,
    iv_BLP_other_FuelEfficiency_nest = FuelEfficiency_sum_mkt - FuelEfficiency_sum_own,
    iv_BLP_other_size_nest = size_sum_mkt - size_sum_own, 
    iv_BLP_own_num_nest = group_n - 1, 
    iv_BLP_other_num_nest = mkt_n - group_n
  ) 

# 続いて、Differentiation IVを構築する。
data <- data %>% 
  dplyr::mutate(
    iv_GH_own_hppw_nest = (group_n - 1) * hppw^2 + (hppw_sqr_sum_own - hppw^2) - 2 * hppw * (hppw_sum_own - hppw),
    iv_GH_own_FuelEfficiency_nest = (group_n - 1) * FuelEfficiency^2 + 
      (FuelEfficiency_sqr_sum_own - FuelEfficiency^2) - 2 * FuelEfficiency * (FuelEfficiency_sum_own - FuelEfficiency),
    iv_GH_own_size_nest = (group_n - 1) * size^2 + (size_sqr_sum_own - size^2) - 2 * size * (size_sum_own - size),
    iv_GH_other_hppw_nest = (mkt_n - group_n) * hppw^2 + (hppw_sqr_sum_mkt - hppw_sqr_sum_own) - 2 * hppw * (hppw_sum_mkt - hppw_sum_own),
    iv_GH_other_FuelEfficiency_nest = (mkt_n - group_n) * FuelEfficiency^2 + 
      (FuelEfficiency_sqr_sum_mkt - FuelEfficiency_sqr_sum_own) - 2 * FuelEfficiency * (FuelEfficiency_sum_mkt - FuelEfficiency_sum_own),
    iv_GH_other_size_nest = (mkt_n - group_n) * size^2 + (size_sqr_sum_mkt - size_sqr_sum_own) - 2 * size * (size_sum_mkt - size_sum_own)
  ) %>%
  dplyr::select(
    -starts_with("sum_own"),
    -starts_with("sum_mkt"),
    -starts_with("sqr_sum_own"),
    -starts_with("sqr_sum_mkt"),
    -mkt_n,
    -group_n
  )　
```

# 入れ子型ロジットモデルの推定とその応用

本誌で導入した、以下のモデルを推定しよう。

$$
\log s_{jt} - \log s_{0t} = -\alpha p_{jt} + \beta'\mathbf{X}_{jt} + \sigma\ln(s_{jt/g}) + \lambda_t + \xi_{jt}
$$

推定に際しては、OLS、BLP操作変数による結果、そしてDifferentiation IVによる結果の3通りについて比較する。

```{r}
# まず被説明変数を定義する。
data <- data %>%
  dplyr::mutate(logit_share = log(share) - log(share0))

# インサイドシェアを定義する。
data <- data %>% 
  dplyr::group_by(year, Type) %>% 
  dplyr::mutate(sum_year_body = sum(Sales)) %>% 
  dplyr::ungroup() %>% 
  dplyr::mutate(
    inside_share = Sales / sum_year_body, 
    log_inside_share = log(Sales / sum_year_body)
  )

# データの保存(第５章で使用)
readr::write_csv(data, "intermediate/chap5_data.csv")
```

```{r}
# OLSの結果
ols <- fixest::feols(
  logit_share ~ price + log_inside_share + hppw + FuelEfficiency + size | 0,
  data = data
)

# GH操作変数を用いた結果
iv_GH <-
  fixest::feols(
    logit_share ~ hppw + FuelEfficiency + size | 0 |
      price + log_inside_share ~ iv_GH_own_hppw_nest + iv_GH_own_FuelEfficiency_nest +
      iv_GH_own_size_nest + iv_GH_other_hppw_nest + iv_GH_other_FuelEfficiency_nest +
      iv_GH_other_size_nest,
    data = data
  )

# BLP操作変数を用いた結果
iv_BLP_nest <-
  fixest::feols(
    logit_share ~ hppw + FuelEfficiency + size | 0 |
      price + log_inside_share ~ iv_BLP_own_hppw_nest + iv_BLP_own_FuelEfficiency_nest + iv_BLP_own_size_nest +
      iv_BLP_other_hppw_nest + iv_BLP_other_FuelEfficiency_nest + iv_BLP_other_size_nest + iv_BLP_own_num_nest +  iv_BLP_other_num_nest,
    data = data
  )


# 推定結果をレポートする。
tbl_nest_iv <- fixest::etable(
  list("OLS" = ols, "IV_BLP" = iv_BLP_nest),  
  se = "hetero",
  fitstat = c("r2", "n", "ivf"), 
  signif.code = NA, 
  dict = c(
    price = "自動車価格",
    hppw = "馬力／重量",
    FuelEfficiency = "燃費 (キロメートル／ 1 リットル)",
    size = "サイズ",
    `(Intercept)` = "定数項"
  ),
  digits = 2,
  digits.stats = 2,
  depvar = FALSE
)

tbl_nest_iv %>%
  knitr::kable(
    align = c("l", "c", "c"),
    booktabs = FALSE,
    format = "html"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE)

# 表の保存
tbl_nest_iv %>%
  knitr::kable(
    align = c("l", "c", "c"),
    booktabs = FALSE,
    format = "latex"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::save_kable("output/chap4_nest_iv.tex")
```



## 入れ子型ロジットモデルにおける自己価格弾力性の計算

各推定結果について、自己価格弾力性を計算しよう。

```{r}
alpha1 <- ols$coefficients["price"]
sigma1 <- ols$coefficients["log_inside_share"]

alpha2 <- iv_BLP_nest$coefficients["fit_price"]
sigma2 <- iv_BLP_nest$coefficients["fit_log_inside_share"]

data_elas <- data %>% 
  dplyr::mutate(
    own_elas_ols = alpha1 * price * (1 - sigma1 * inside_share - (1 - sigma1) * share) / (1 - sigma1),
    own_elas_ivblp = alpha2 * price * (1 - sigma2 * inside_share - (1 - sigma2) * share) / (1 - sigma2)
  )

tbl_nest_own_elas <- data_elas %>% 
  dplyr::select(starts_with("own_elas")) %>% 
  summarytools::descr(
    transpose = TRUE, 
    stats = c("mean", "sd", "med", "min", "max"),
    order = "preserve"
  )

print(tbl_nest_own_elas)

# 表の保存
tbl_nest_own_elas %>%
  knitr::kable(
    align = rep("l", 5),
    digits = 2,
    booktabs = FALSE,
    format = "latex"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::save_kable("output/chap4_nest_own_elas.tex")
```



価格弾力性行列を作る。

```{r}
data_NIPPYO <- data %>% 
  dplyr::filter(Nippyo == 1) %>%
  dplyr::select(year, share, Type, inside_share, NameID, Sales, price, hppw, FuelEfficiency, size) %>% 
  dplyr::mutate(
    log_sales = log(Sales),
    log_price = log(price)
  ) 

dt2016 <- data_NIPPYO %>% 
  dplyr::filter(year == 2016) %>% 
  dplyr::select(price, Type, share, inside_share, NameID) %>% 
  dplyr::arrange(NameID)

price <- dt2016$price
share <- dt2016$share
NameID <- dt2016$NameID
inside_share <- dt2016$inside_share
group <- dt2016$Type

# Own elasticity
own_elas <- alpha2 * price * (1 - sigma2 * inside_share - (1 - sigma2) * share) / (1 - sigma2)

# Cross elasticity outside the group
cross_elas_othergroup <- (-1) * alpha2 * price * share
J <- length(own_elas)
cross_elas_othergroup <- matrix(rep(cross_elas_othergroup, J), nrow = J, ncol = J)

# Cross elasticity within the group (matrix representation)
price_l_mat <- matrix(rep(price, J), nrow = J, ncol = J)
share_l_mat <- matrix(rep(share, J), nrow = J, ncol = J)
insideshare_l_mat <- matrix(rep(inside_share, J), nrow = J, ncol = J)
cross_elas_samegroup <- (-1) * alpha2 * price_l_mat * (sigma2 * insideshare_l_mat + (1 - sigma2) * share_l_mat) / (1 - sigma2)

# Indicator of group
temp_mat1 <- matrix(rep(group, J), nrow = J, ncol = J)
temp_mat2 <- t(temp_mat1)
ind_same_group <- (temp_mat1 == temp_mat2)
ind_other_group <- (temp_mat1 != temp_mat2)

# Construct Elasticity Matrix
elas_mat_nl <- cross_elas_samegroup * ind_same_group + cross_elas_othergroup * ind_other_group
diag(elas_mat_nl) <- own_elas

elas_mat_nl_restricted <- elas_mat_nl[NameID %in% c(betard, sedan, suv, kei), NameID %in% c(betard, sedan, suv, kei)]
Name <- c("ベータード", "セダン(A)", "SUV(B)", "軽自動車(C)")
colnames(elas_mat_nl_restricted) <- Name
rownames(elas_mat_nl_restricted) <- Name

elas_mat_nl_restricted %>%
  knitr::kable(
    align = rep("c", 4),
    digits = 4,
    booktabs = FALSE,
    format = "html"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE)

# 表の保存
elas_mat_nl_restricted %>%
  knitr::kable(
    align = rep("c", 4),
    digits = 4,
    booktabs = FALSE,
    format = "latex"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::save_kable("output/chap4_elas_mat_nest.tex")
```


# ランダム係数ロジットモデルの推定
## 定式化

以下の定式化を考える。

$$
\begin{eqnarray}
u_{i j t}=& \beta_{i}^{0}+\beta_{i}^{size}{size}_{j t}+\beta^{\textit{fuelefficiency}}\textit{fuelefficiency}_{jt} 
+\beta^{h p p w} h p p w_{j t}
-\alpha_{i} p_{j t}+\xi_{j t}+\epsilon_{i j t}
\end{eqnarray}
$$

ここで、$\beta_{i}^{0}, \beta_{i}^{size}, \alpha_i$は正規分布に従うランダム係数である。

## 推定のOverview

Step 1はデータに関する下準備である。

Step 2から4では、GMM推定のために必要な関数を順番に用意していく。

1. 市場シェアを計算する関数 (Step 2)
2. 縮小写像によるBerryインバージョンを行う関数 (Step 3)
3. GMMの目的関数 (Step 4)

市場シェアを計算する関数はStep 3・4両方で使用する。また、Berryインバージョンを行う関数はGMM目的関数を評価する際に必要となる。
GMM目的関数を定義した後、数値最適化でGMM推定を行う。

Step 5では推定したパラメタの標準誤差の計算を行う。最後に推定結果をテーブルでまとめる。


## Step 1:下準備

まずは、データセットから、行列を抽出する。

```{r}
# まずデータをソートする。マーケット順かつモデル順
data <- data %>% 
    dplyr::arrange(year, NameID)

# マーケットとモデルの情報をGET
Info <- data %>% 
    dplyr::select(year, NameID)

N <- length(Info$year)
T <- length(unique(Info$year))

# 平均効用に入ってくる部分。内生性がある価格を含んでいる。
X1 <- data %>%
  dplyr::mutate(cons = 1) %>%
  dplyr::select(cons, price, FuelEfficiency, hppw, size) %>%
  as.matrix()

# ランダム係数とInteractする部分。
X2 <- data %>%
  dplyr::mutate(cons = 1) %>%
  dplyr::select(price, cons, size) %>%
  as.matrix()

# 操作変数行列。ここは外生変数と追加的な操作変数を含む
Z <- data %>%
  dplyr::mutate(cons = 1) %>%
  dplyr::select(
    cons, FuelEfficiency, hppw, size,
    starts_with("iv_GH"),
    -ends_with("nest")
  ) %>%
  as.matrix()

# 市場シェア
ShareVec <- data %>%
  dplyr::select(share) %>%
  as.matrix()

datalist <- list()
datalist$X1 <- X1
datalist$X2 <- X2
datalist$Z <- Z
datalist$ShareVec <- ShareVec
datalist$marketindex <- data$year
datalist$logitshare <- data$logit_share
```

次に、乱数を用意しておく。

```{r}
set.seed(111)

Nsim <- 500

draw_vec <- rnorm(Nsim * ncol(X2))

datalist$draw_vec <- draw_vec

parameter <- list()
parameter$Nsim <- Nsim
parameter$T <- T 
parameter$N <- N
parameter$theta2 = c(0.001, 0.001)

marketindex <- datalist$marketindex
uniquemarketindex <- sort(unique(marketindex))
temp1 <- matrix(rep(uniquemarketindex, N), T, N) %>% t()
temp2 <- matrix(rep(marketindex, T), N, T)
tempmat <- (temp1 == temp2) * 1
datalist$tempmat <- tempmat
```

## Step 2: 市場シェアの計算コード

ここでは、市場シェアを計算する関数`f_mktshare`を定義しよう。

```{r}
f_mktshare <- function(datalist, parameter, delta) {
    
    # Unpack data
    X2 <- datalist$X2
    ns <- parameter$Nsim
    T <- parameter$T
    N <- parameter$N
    
    draw_vec <- datalist$draw_vec
    
    theta2 <- parameter$theta2
    K2 <- length(theta2)
    
    draw_vec <- datalist$draw_vec[1:(ns * K2)]
    
    marketindex <- datalist$marketindex
    
    # Nonlinear component. mu (N, ns) matrix.
    mu <- X2 %*% diag(x = theta2, nrow = length(theta2)) %*% matrix(draw_vec, nrow = K2)
    
    denom_outside <- exp(matrix(0, T, ns))
    
    delta_mu <-  delta %*% matrix(1, nrow = 1, ncol = ns) + mu
    exp_delta_mu <- exp(delta_mu)
    
    # ロジット確率の分母を計算する。これは、市場ごとに和を計算する。
    tempmat <- datalist$tempmat
    
    denom_temp <- t(t(exp_delta_mu) %*% tempmat)
    denom_temp <- denom_temp + denom_outside
    
    # denom is (N * ns) matrix that captures the denominator of the logit prob.
    denom <- tempmat %*% denom_temp
    
    # Choice prob for individual (N * ns) matrix
    s_jt_i <- exp_delta_mu / denom
    
    # Market share (N * 1) vector
    s_jt <- apply(s_jt_i, 1, mean)

    return(s_jt)
}
```

## Step 3: 縮小写像によるBerryインバージョンのコード

ここでは、Berryインバージョンによる平均効用の計算を行う関数を定義する。なお、関数の内部でStep2で定義した`f_mktshare`を利用している。


```{r}
f_contraction <- function(datalist, parameter, delta_ini) {
    
    tol <- 1e-11
    share_obs <- datalist$ShareVec
    norm <- 1e+10
    
    delta_old <- delta_ini
    exp_delta_old <- exp(delta_old)
    
    iter <- 0
    
    while (norm > tol && iter < 1000) {
        
        pred_mkt_share <- f_mktshare(datalist, parameter, delta_old)
        
        exp_delta <- exp_delta_old * share_obs / pred_mkt_share
        
        t <- abs(exp_delta - exp_delta_old)
        norm <- max(t)
        
        # Update
        # exp_delta_old <- 0.95 * exp_delta + 0.05 * exp_delta_old
        exp_delta_old <- exp_delta 
        
        delta_old <- log(exp_delta)
        iter <- iter + 1
    }
    return(log(exp_delta))
}
```

## Step 4: GMM 目的関数を定義し、数値最適化する

ここでは、非線形パラメタ`theta2`に対してGMM目的関数を返す関数`f_GMMobj`を定義する。以下、関数の留意点をいくつか。


1. 以下では変数`delta_global`をグローバル変数として扱っており、関数`f_GMMobj`を評価するたびに、`delta_global`もアップデートするようになっている。この変数は、`f_GMMobj`を評価する際に必要となる縮小写像アルゴリズムの初期値である。最適化が進むにつれて`f_GMMobj`が評価するパラメタが徐々に変化するが、その評価の際に必要な縮小写像アルゴリズムの初期値もなるべく近いパラメタの元で得られた平均効用を用いる方が、計算速度上望ましい。なおここでは、永続代入演算子`delta_global <<- delta`を利用しているが、その詳細については後述する。
2. GMM目的関数のインプットは非線形パラメタ`theta2`のみである。これは、平均効用に線形の形で入ってくるパラメタ$\theta_1$は、非線形パラメタを所与とすると線形GMMで解析的に求まるためである。

```{r}
f_GMMobj <- function(theta2, parameter, datalist, option) {
  
  # 引数option
  # 0:最適化の際に指定
  # 1:推定値やmean utility(delta)を得る際に指定

  param <- parameter
  param$theta2 <- theta2

  # Contractionの初期値として、グローバル変数のdelta_globalを用いる。
  delta_ini <- delta_global

  # Contraction mapping
  delta <- f_contraction(datalist, param, delta_ini)
  
  # 平均効用を永続代入演算子でアップデートしている。 
  delta_global <<- delta

  # Obj function
  X1 <- datalist$X1

  # IV matrix
  Z <- datalist$Z

  # Weight matrix W
  if (datalist$weight_mat_option == "2SLS") {
    W <- solve(t(Z) %*% Z)
  } else if (datalist$weight_mat_option == "Ident") {
    W <- eye(dim(Z)[2])
  } else if (is.null(datalist$weight_mat_option)) {
    stop("SET 'datalist$weight_mat_option' !!")
  }

  # Obtain linear parameter by regression
  # beta_hat2 = solve( t(X1)%*%X1 )%*%t(X1)%*%delta

  beta_hat <- solve(t(X1) %*% Z %*% W %*% t(Z) %*% X1) %*% t(X1) %*% Z %*% W %*% t(Z) %*% delta

  Xi <- delta - X1 %*% beta_hat

  # Objective function

  output <- t(Xi) %*% Z %*% W %*% t(Z) %*% Xi

  # optionによって戻り値を変える
  if (option == 0) {
    return(output = output)
  } else if (option == 1) {
    return(list(output = output, beta_hat = beta_hat, delta = delta))
  } else {
    stop(
      "SET the argument 'option' to 0 or 1 !! \n 
      0: Specify when optimizing \n
      1: Specify when getting coefficient and mean utility (delta)"
    )
  }
}
```

定義した関数を用いて、実際にGMM推定をしてみよう。

```{r}
# GMMの荷重行列のオプション
datalist$weight_mat_option <- "2SLS"

# グローバル変数としてアップデートする平均効用
delta_global <- data$logit_share

# 最適化
result <- stats::optim(
  par = c(0.3, 18, 0.01),
  fn = f_GMMobj,
  method = "L-BFGS-B",
  lower = c(0, 0, 0),
  parameter = parameter,
  datalist = datalist,
  option = 0
)
```

### 技術的な補足：永続代入演算子とグローバル変数

通常、関数内部における変数はローカル変数と呼ばれ、関数内で処理が完結し、関数の外（すなわちワークスペース）の変数には影響を与えない。一方、永続代入演算子`<<-`を用いることで、関数内部での処理によって、関数の外の変数を変更することが可能である。このような変数をグローバル変数と呼ぶ。通常、永続代入演算子やグローバル変数を用いることは、変数間の関係が煩雑になったり、予期しない変数のアップデートが起きうる点から望ましくない。
今回は計算速度を早めるべく利用しているが、そのような場合にも永続代入演算子を利用していることを明示的することが、コードをクリアに書く上で重要である。


## Step 5: 標準誤差の計算

ここでは標準誤差を計算する関数を定義し、その上で計算する。

```{r}
f_SE <- function(theta2, parameter, datalist) {
  param <- parameter
  param$theta2 <- theta2

  delta_ini <- datalist$logitshare

  # Contraction mapping
  delta <- f_contraction(datalist, param, delta_ini)

  # Obj function
  X1 <- datalist$X1

  # IV matrix
  Z <- datalist$Z

  # Weight matrix W
  if (datalist$weight_mat_option == "2SLS") {
    W <- solve(t(Z) %*% Z)
  } else if (datalist$weight_mat_option == "Ident") {
    W <- eye(dim(Z)[2])
  } else if (is.null(datalist$weight_mat_option)) {
    STOP("SET 'datalist$weight_mat_option' !!")
  }

  # Obtain linear parameter by regression
  beta_hat <- solve(t(X1) %*% Z %*% W %*% t(Z) %*% X1) %*% t(X1) %*% Z %*% W %*% t(Z) %*% delta

  # ResidualをGetする。
  Xi <- delta - X1 %*% beta_hat

  # Omega
  Omega_hat <- matrix(0, nrow = ncol(Z), ncol = ncol(Z))
  for (ii in 1:param$N) {
    Omega_hat <- Omega_hat + (matrix(Z[ii, ]) %*% t(matrix(Z[ii, ])) * Xi[ii]^2) / parameter$N
  }
  
  # Gradient of delta. 単純化のために数値微分で計算する。
  Ddelta <- matrix(0, nrow = parameter$N, ncol = length(theta2))

  for (k in 1:length(theta2)) {
    tempparam <- param
    tempparam$theta2[k] <- theta2[k] + 1e-6

    delta_add <- f_contraction(datalist, tempparam, delta_ini)

    Ddelta[, k] <- (delta_add - delta) / 1e-6
  }

  G <- (parameter$N^(-1)) * t(Z) %*% cbind(-X1, Ddelta)

  # Asymptotic Var-Cov Matrix
  AsyVarMat <- solve(t(G) %*% W %*% G) %*% t(G) %*% W %*% Omega_hat %*% W %*% G %*% solve(t(G) %*% W %*% G)
  
  # Asymptotic Standard Errors.
  Ase <- sqrt(diag(AsyVarMat) / parameter$N)

  return(Ase)
}
```


以上の関数を用いて標準誤差を計算する。


```{r}
result2 <- f_GMMobj(result$par, parameter, datalist, option = 1)

delta <- result2$delta

se <- f_SE(theta2 = result$par, parameter = parameter, datalist = datalist)
```


## ランダム係数ロジットの推定結果

```{r}
beta_hat <- rbind(result2$beta_hat, result$par[1], result$par[2], result$par[3])
rownames(beta_hat)[length(result2$beta_hat) + 1] <- "random_price"
rownames(beta_hat)[length(result2$beta_hat) + 2] <- "random_constant"
rownames(beta_hat)[length(result2$beta_hat) + 3] <- "random_size"
colnames(beta_hat) <- "coeff"
names(se)[length(result2$beta_hat) + 1] <- "random_price"
names(se)[length(result2$beta_hat) + 2] <- "random_constant"
names(se)[length(result2$beta_hat) + 3] <- "random_size"

result_table <-
  as.data.frame(beta_hat) %>%
  dplyr::mutate(se = se)

result_table %>%
  knitr::kable(
    align = c("l", rep("c", 2)),
    digits = 2, 
    booktabs = FALSE, 
    format = "html",
    caption = "Estimates of The Parameters"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE)

# 表の保存
result_table %>%
  knitr::kable(
    align = c("l", rep("c", 2)),
    digits = 2, 
    booktabs = FALSE, format = "latex",
    caption = "Estimates of The Parameters"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::save_kable("output/chap4_blp.tex")
```


# 価格弾力性行列の計算

まず価格弾力性を計算する関数を定義する。

```{r}
f_elasticity <- function(datalist, parameter, beta_hat, delta) {
  
  # Unpack data
  X2 <- datalist$X2
  ns <- parameter$Nsim
  N <- parameter$N
  price <- datalist$X1[, colnames(datalist$X1) == "price"] %>% as.matrix()
  theta2 <- parameter$theta2
  K2 <- length(theta2)
  draw_vec <- datalist$draw_vec[1:(ns * K2)]
  uniquemarketindex <- datalist$uniquemarketindex
  
  # 以下マーケットシェアの関数とほぼ同じ
  # Nonlinear component. mu (N, ns) matrix.
  mu <- X2 %*% diag(x = theta2, nrow = length(theta2)) %*% matrix(draw_vec, nrow = K2)
  
  denom_outside <- exp(matrix(0, T, ns))
  delta_mu <- delta %*% matrix(1, nrow = 1, ncol = ns) + mu
  exp_delta_mu <- exp(delta_mu)
  tempmat <- datalist$tempmat
  denom_temp <- t(t(exp_delta_mu) %*% tempmat)
  denom_temp <- denom_temp + denom_outside
  
  denom <- tempmat %*% denom_temp
  
  # Choice prob for individual (N * ns) matrix
  s_jt_i <- exp_delta_mu / denom
  
  # Price parameter alpha_i
  draw_for_price <- matrix(draw_vec, nrow = K2)[1, ]
  alpha_i <- beta_hat[rownames(beta_hat) == "price"] + beta_hat[rownames(beta_hat) == "random_price"] * draw_for_price
  
  # 弾力性行列を保存する空のリストを作成する
  elaslist <- as.list(rep(NA, T))
  
  # 各マーケットごとに弾力性行列を作成する．
  for (t in 1:T) {
    
    # マーケットの表示
    #cat("calculate the elasticity for Market", uniquemarketindex[t], "\n")
    
    # Number of products 
    J_t <- sum(marketindex == 2005 + t)
    
    # それぞれのマーケットに注目した(J*ns)の選択確率の行列を作成する
    # あるマーケットに対して，製品ごとに集計した選択確率の行列(J*ns)を作成する
    ag_model_s_i <- s_jt_i[marketindex == 2005 + t,]
    
    # 製品ごとの選択確率のベクトル(J * 1)
    ag_model_s <- apply(ag_model_s_i, 1, mean) %>% as.matrix()
    
    # 空の弾力性行列(J * J)を定義
    elasmat <- matrix(0, nrow = J_t, ncol = J_t)
    
    # あるマーケットに注目した，製品ごとの価格のベクトル(J*1)を作成する
    price_t <- price[marketindex == 2005 + t]
    
    # 弾力性を計算し，弾力性行列を作成する
    for (k in 1:J_t) {
      for (j in 1:J_t) {
        if (k != j) {
          # cross elasticity
          elasmat[k, j] <- (-1)*price_t[k] * ag_model_s[j, ]^(-1) * mean(alpha_i * ag_model_s_i[j, ] * ag_model_s_i[k, ])
        } else if (k == j) {
          # Own elasticity
          elasmat[k, j] <- price_t[j] * ag_model_s[j, ]^(-1) * mean(alpha_i * ag_model_s_i[j, ] * (1 - ag_model_s_i[j, ]) )
        } 
      }
    }
    
    # 弾力性行列をマーケットごとに名前を付けて保存する．
    elaslist[[t]] <- elasmat
    names(elaslist)[[t]] <- sprintf("elasmat_%d", t + 2005)
  }
  return(elaslist)
}
```

早速、価格弾力性行列を示そう。

```{r}
# 弾力性の表示の前処理
parameter$theta2 <- result$par

elasticity <- f_elasticity(datalist = datalist, parameter = parameter, beta_hat = beta_hat, delta = delta)

NameID2016 <- data %>% 
  dplyr::filter(year == 2016) %>%
  dplyr::select(NameID) %>% 
  dplyr::pull()

elas_mat_blp_restricted <- elasticity$elasmat_2016[NameID2016 %in% c(betard, sedan, suv, kei), NameID2016 %in% c(betard, sedan, suv, kei)]

Name <- c("ベータード", "セダン(A)", "SUV(B)", "軽自動車(C)")
colnames(elas_mat_blp_restricted) <- Name
rownames(elas_mat_blp_restricted) <- Name

elas_mat_blp_restricted %>%
  knitr::kable(
    align = rep("c", 4),
    digits = 4,
    booktabs = FALSE,
    format = "html"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE)

# 表の保存
elas_mat_blp_restricted %>%
  knitr::kable(
    align = rep("c", 4),
    digits = 4,
    booktabs = FALSE, 
    format = "latex"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::save_kable("output/chap4_elas_mat_blp.tex")
```


# 応用：プライシング

## 需要曲線と収入曲線を書く

需要関数の推定結果にもとづいて、需要曲線を書こう。前回と手順は同様である。

1.  まず、推定結果から$\xi_{jt}$をゲットする。
2.  関数を作成する。
3.  どこか市場を固定する。
4.  製品を一つ固定する。
5.  その製品の価格を変えたときに、どの製品のSalesがどう変わるかをPredictする。その際、他の製品価格はデータのものに固定しておく。


まず関数を定義する。

```{r}
NIPPYOautoIDvec <- data_NIPPYO %>%
  dplyr::distinct(NameID) %>%
  dplyr::pull()

f_revenue <- function(price_cand, data , datalist , datalist_temp, result2, parameter, option) {
  
  # ベータードの限界費用。今回はラーナーの公式から簡便的に定義する。より詳しい内容は第5章を参照。
  mc_betado <- 3.198 * (1 - 1 / abs(-2.16720791))

  tempprice <- data$price
  tempprice[data$NameID == betard & data$year == 2016] <- price_cand
  
  datalist_temp <- datalist
  datalist_temp$X1[, "price"] <- tempprice
  datalist_temp$X2[, "price"] <- tempprice
  
  # Re-calculate 平均効用 with new price
  org_xi <- result2$delta - datalist$X1 %*% result2$beta_hat
  new_delta <- datalist_temp$X1 %*% result2$beta_hat + org_xi
  
  mktshare <- f_mktshare(datalist = datalist_temp  , parameter = parameter, delta = new_delta)
  
  quant <- mktshare * data$HH
  revenue <- tempprice * quant
  
  # ベータードのみの収入
  revenuevec <-　revenue[data$NameID == betard & data$year == 2016]

  # 日評自動車全体の収入
  revenuevec2 <-　sum(revenue[data$NameID %in% NIPPYOautoIDvec & data$year == 2016] )
  
  
  # ベータードのみの利潤
  pivec <- revenuevec-mc_betado * quant[data$NameID == betard & data$year == 2016]
  
  # ベータードのみの利潤+日評自動車の他の車種の収入
  pivec2 <- revenuevec2 - mc_betado * quant[data$NameID == betard & data$year == 2016]

  if (option == "own"){
    return(revenuevec)
  } else if (option == "total") {
    return(revenuevec2)
  } else if (option == "ownpi") {
    return(pivec)
  } else if (option == "totalpi") {
    return(pivec2)
  }
  
}
```

定義した関数を用いて、まず図を作成する。

```{r}
NameID_target <- betard

pricevec <- seq(from = 1.73, to = 4, by = 0.01)
pivec <- numeric(length(pricevec))
pivec2 <- numeric(length(pricevec))

for (i in 1:length(pricevec)) {
  # ベータードのみの利潤
  pivec[i] <- f_revenue(pricevec[i], data, datalist, datalist_temp, result2, parameter, option = "ownpi")
  
  # ベータードのみの利潤+日評自動車の他の車種の収入
  pivec2[i] <- f_revenue(pricevec[i], data, datalist, datalist_temp, result2, parameter, option = "totalpi")
}

# ベータードのみ
dt_fig1 <- dplyr::tibble(
  price = pricevec * 100, 
  pi1 = pivec * 100 / 10000
) %>% 
  tidyr::pivot_longer(-price, names_to = "name")

fig_pi1 <- ggplot2::ggplot(dt_fig1, aes(price, value)) + 
  ggplot2::geom_point() +
  ggplot2::theme_bw(base_family = "HiraKakuPro-W3") +
  ggplot2::theme(
    axis.title.y = element_text(angle = 0, vjust = 0.5),
    panel.grid.major.y = element_line(
      color = "grey",
      linewidth = 0.3,
      linetype = "dotted"
    ),
    panel.grid.minor.y = element_line(
      color = "grey",
      linewidth = 0.3,
      linetype = "dotted"
    ),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(colour = "black", linewidth = 0.2)) + 
  ggplot2::scale_x_continuous(breaks = seq(0, 500, 50)) + 
  ggplot2::labs(
    y = "収入(億円)",
    x = "価格(万円)"
  ) 

plot(fig_pi1)

ggsave(fig_pi1, file = "output/chap4_revenue_betard.png", width = 9, height = 6)
ggsave(fig_pi1, file = "output/chap4_revenue_betard.pdf", width = 9, height = 6, device = cairo_pdf)

# ベータードのみの利潤+日評自動車の他の車種の収入
dt_fig2 <- dplyr::tibble(
  price = pricevec * 100, 
  pi2 = pivec2 * 100 / 10000
) %>% 
  tidyr::pivot_longer(-price, names_to = "name")

fig_pi2 <- ggplot2::ggplot(dt_fig2, aes(price, value)) + 
  ggplot2::geom_point() +
  ggplot2::theme_bw(base_family = "HiraKakuPro-W3") +
  ggplot2::theme(
    axis.title.y = element_text(angle = 0, vjust = 0.5),
    panel.grid.major.y = element_line(
      color = "grey",
      linewidth = 0.3,
      linetype = "dotted"
    ),
    panel.grid.minor.y = element_line(
      color = "grey",
      linewidth = 0.3,
      linetype = "dotted"
    ),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(colour = "black", linewidth = 0.2)) +
  ggplot2::scale_x_continuous(breaks = seq(0, 500, 50)) + 
  ggplot2::labs(
    y = "収入(億円)",
    x = "価格(万円)"
  ) 

plot(fig_pi2)

ggsave(fig_pi2, file = "output/chap4_revenue_all.png", width = 9, height = 6)
ggsave(fig_pi2, file = "output/chap4_revenue_all.pdf", width = 9, height = 6, device = cairo_pdf)
```

最後に、数値最適化を使って、利潤を最大にする価格を求める。

まずベータードのみ
```{r}
# ベータードのみ
optimprice3 <- stats::optimise(
  f_revenue, interval = c(0.3, 5), maximum = TRUE, 
  data = data, datalist = datalist, result2 = result2,
  parameter = parameter, option = "ownpi"
)

print(optimprice3)
```

つづいてベータードのみの利潤+日評自動車の他の車種の収入

```{r}
optimprice4 <- stats::optimise(
  f_revenue, interval = c(0.3, 5), maximum = TRUE, 
  data = data, datalist = datalist, result2 = result2,
  parameter = parameter, option = "totalpi"
)
print(optimprice4)
```

ベータードのみの利潤を最大にするような価格における、「ベータードのみの利潤+日評自動車の他の車種の収入」はどうなるか？

```{r}
f_revenue(
  price = optimprice3$maximum,
  data = data, datalist = datalist, result2 = result2,
  parameter = parameter, option = "totalpi"
)
```